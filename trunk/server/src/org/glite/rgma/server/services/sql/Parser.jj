options{  STATIC = false;  IGNORE_CASE = true;}PARSER_BEGIN(Parser)package org.glite.rgma.server.services.sql.parser;import java.util.*;import org.glite.rgma.server.services.sql.Constant.Type;import org.glite.rgma.server.services.sql.JoinedTable.*;import org.glite.rgma.server.services.sql.*;/**
 * SQL parser for R-GMA.
 */public class Parser{}PARSER_END(Parser)SKIP :{  " "| "\t"| "\r"| "\n"}/* Prefix      Meaning
    -------------------
    K_          Keyword
    S_          Substitutes
*/TOKEN : /* SQL Keywords. prefixed with K_ to avoid name clashes */{  < K_ALL : "ALL" >| < K_AND : "AND" >| < K_AS : "AS" >| < K_ASC : "ASC" >| < K_AUTO_INCREMENT : "AUTO_INCREMENT" >| < K_AVG : "AVG" >| < K_BETWEEN : "BETWEEN" >| < K_BY : "BY" >| < K_CHAR : "CHAR" >| < K_COMMENT : "COMMENT" >| < K_COMMIT : "COMMIT" >| < K_CONNECT : "CONNECT" >| < K_COUNT : "COUNT" >| < K_CREATE : "CREATE" >| < K_DATE : "DATE" >| < K_DELETE : "DELETE" >| < K_DESC : "DESC" >| < K_DISTINCT : "DISTINCT" >| < K_EXCLUSIVE : "EXCLUSIVE" >| < K_EXISTS : "EXISTS" >| < K_FOR : "FOR" >| < K_FROM : "FROM" >| < K_GROUP : "GROUP" >| < K_HAVING : "HAVING" >| < K_IN : "IN" >| < K_INDEX : "INDEX" >| < K_INSERT : "INSERT" >| < K_INTEGER : "INTEGER" >| < K_INTO : "INTO" >| < K_IS : "IS" >| < K_LIKE : "LIKE" >| < K_KEY : "KEY" >| < K_MAX : "MAX" >| < K_MIN : "MIN" >| < K_MODE : "MODE" >| < K_NATURAL : "NATURAL" >| < K_NOT : "NOT" >| < K_NOWAIT : "NOWAIT" >| < K_NULL : "NULL" >| < K_OF : "OF" >| < K_ONLY : "ONLY" >| < K_OR : "OR" >| < K_ORDER : "ORDER" >| < K_PRIMARY : "PRIMARY" >| < K_QUIT : "QUIT" >| < K_READ : "READ" >| < K_REAL : "REAL" >| < K_ROLLBACK : "ROLLBACK" >| < K_ROW : "ROW" >| < K_SELECT : "SELECT" >| < K_SET : "SET" >| < K_SHARE : "SHARE" >| < K_START : "START" >| < K_SUM : "SUM" >| < K_TABLE : "TABLE" >| < K_UNION : "UNION" >| < K_UPDATE : "UPDATE" >| < K_VALUES : "VALUES" >| < K_VARCHAR : "VARCHAR" >| < K_VIEW : "VIEW" >| < K_WHERE : "WHERE" >| < K_WITH : "WITH" >| < K_WORK : "WORK" >| < K_WRITE : "WRITE" >| < K_TIME : "TIME" >| < K_TIMESTAMP : "TIMESTAMP" >| < K_DOUBLE : "DOUBLE" >| < K_PRECISION : "PRECISION" >| < K_FULL : "FULL" >| < K_JOIN : "JOIN" >| < K_ON : "ON" >| < K_LEFT : "LEFT" >| < K_RIGHT : "RIGHT" >| < K_OUTER : "OUTER" >| < K_INNER : "INNER" >| < K_USING : "USING" >}TOKEN : /* Numeric Constants */{  < S_NUMBER :    < FLOAT >  | < FLOAT >    (      [ "e", "E" ] ([ "-", "+" ])? < FLOAT >    )? >| < #FLOAT :    < INTEGER >  | < INTEGER > ("." < INTEGER >)?  | "." < INTEGER > >| < #INTEGER : (< DIGIT >)+ >| < #DIGIT : [ "0"-"9" ] >}SPECIAL_TOKEN :{  < LINE_COMMENT : "--" (~[ "\r", "\n" ])* >| < MULTI_LINE_COMMENT :    "/*" (~[ "*" ])* "*"    (      "*"    |      (        ~[ "*", "/" ] (~[ "*" ])* "*"      )    )*    "/" >}TOKEN :{  < S_IDENTIFIER :    (< LETTER >)+    (      < DIGIT >    | < LETTER >    | < SPECIAL_CHARS >    )* >| < #LETTER : [ "a"-"z", "A"-"Z" ] >| < #SPECIAL_CHARS :    "$"  | "_" >| < S_BIND : ":" < S_IDENTIFIER > ("." < S_IDENTIFIER >)? >| < S_CHAR_LITERAL :    "'" (~[ "'" ])* "'"    (      "'" (~[ "'" ])* "'"    )* >}DataType DataType() :{  Token sn;  DataType dataType = new DataType();}{  (    /* types of the form TYPENAME[(int)] */    (      "CHAR"      {        dataType.setType(DataType.Type.CHAR);      }    | "TIMESTAMP"      {        dataType.setType(DataType.Type.TIMESTAMP);      }    | "TIME"      {        dataType.setType(DataType.Type.TIME);      }    )    [      "(" sn = < S_NUMBER >      {        dataType.setSize(Integer.parseInt(sn.toString()));      }      ")"    ]  | /* types of the form TYPENAME(int) */"VARCHAR"    {      dataType.setType(DataType.Type.VARCHAR);    }    "(" sn = < S_NUMBER >    {      dataType.setSize(Integer.parseInt(sn.toString()));    }    ")"  | /* types of the form TYPENAME */"INTEGER"    {      dataType.setType(DataType.Type.INTEGER);    }  | "REAL"    {      dataType.setType(DataType.Type.REAL);    }  | "DOUBLE" "PRECISION"    {      dataType.setType(DataType.Type.DOUBLE_PRECISION);    }  | "DATE"    {      dataType.setType(DataType.Type.DATE);    }  )  {    return dataType;  }}String Modifier() :{}{  < K_NOT > < K_NULL >  {    return "NOT NULL";  }| < K_PRIMARY > < K_KEY >  {    return "PRIMARY KEY";  }}/* ---------------- DECLARATIONS SECTION ends here ------------------ *//* ---------------- Code Section starts here ---------------------- */// ColumnValues ::= TableColumn = UpdatedValue (, TableColumn = UpdatedValue)*
Map < String, ExpressionOrConstant > ColumnValues() :{  Map < String, ExpressionOrConstant > t = new Hashtable < String, ExpressionOrConstant > ();  String key;  ExpressionOrConstant val;}{  key = TableColumn() "=" val = UpdatedValue()  {    t.put(key, val);  }  (    "," key = TableColumn() "=" val = UpdatedValue()    {      t.put(key, val);    }  )*  {    return t;  }}// UpdatedValue ::= SQLExpression
ExpressionOrConstant UpdatedValue() : // Can be a subquery or a expression
{  ExpressionOrConstant e;}{  e = SQLExpression()  {    return e;  }}// UpdateStatement ::= "UPDATE" TableName "SET" SetClauseList
//                     [ "WHERE" SQLExpression ] [";"]
UpdateStatement UpdateStatement() :{  String tableName;  UpdateStatement us;  ExpressionOrConstant where;  Map < String, ExpressionOrConstant > setClauseList;}{  "UPDATE" tableName = ObjectName()  {    us = new UpdateStatement(new TableName(tableName));  }  "SET" setClauseList = SetClauseList()  {    us.setSet(setClauseList);  }  [    "WHERE" where = SQLExpression()    {      us.setWhere(where);    }  ]  [ ";" ]  {    return us;  }}// InsertStatement ::= "INSERT INTO" TableName "(" ColumnName ( "," ColumnName )* ")"//                     "VALUES"  "(" ColumnValue ( "," ColumnValue )* ")" [";"]InsertStatement InsertStatement() :{  TableName tableName;  String columnName;  Constant columnValue;  InsertStatement is;  List < String > columnNames = new ArrayList < String > (8);  List < Constant > columnValues = new ArrayList < Constant > (8);}{  "INSERT" "INTO" tableName = TableName()  {    is = new InsertStatement(tableName);  }  "(" columnName = ColumnName()  {    columnNames.add(columnName);  }  (    "," columnName = ColumnName()    {      columnNames.add(columnName);    }  )*  ")" "VALUES" "(" columnValue = ColumnValue()  {    columnValues.add(columnValue);  }  (    "," columnValue = ColumnValue()    {      columnValues.add(columnValue);    }  )*  ")" [ ";" ]  {    is.setColumnNames(columnNames);    is.setColumnValues(columnValues);    return is;  }}// SetClauseList ::= SetClause() ( "," SetClause() )*
// SetClause ::= ObjectName() "=" SQLSimpleExpression()
Map < String, ExpressionOrConstant > SetClauseList() :{  Map < String, ExpressionOrConstant > setClauseList = new HashMap < String, ExpressionOrConstant > ();  String columnName;  ExpressionOrConstant updateValue;}{  columnName = ObjectName() "=" updateValue = SQLSimpleExpression()  {    setClauseList.put(columnName, updateValue);  }  (    "," columnName = ObjectName() "=" updateValue = SQLSimpleExpression()    {      setClauseList.put(columnName, updateValue);    }  )*  {    return setClauseList;  }}// QueryStatement ::= SelectStatement() [";"]
SelectStatement QueryStatement() :{  SelectStatement q;}{  q = SelectStatement() [ ";" ]  {    return q;  }}// CreateViewStatement ::= CREATE VIEW ObjectName AS SELECT (ObjectName (, ObjectName)* ) FROM ObjectName [";"]
CreateViewStatement CreateViewStatement() :{  CreateViewStatement cvs;  String viewName, tableName, columnName;  List < String > columnNames = new ArrayList < String > ();}{  "CREATE" "VIEW" viewName = ObjectName()  {    cvs = new CreateViewStatement(viewName);  }  "AS" "SELECT" columnName = ObjectName()  {    cvs.setColumnNames(columnNames);    columnNames.add(columnName);  }  (    "," columnName = ObjectName()    {      columnNames.add(columnName);    }  )*  "FROM" tableName = ObjectName()  {    cvs.setTableName(tableName);  }  [ ";" ]  {    return cvs;  }}// CreateIndexStatement ::= CREATE INDEX ObjectName ON ObjectName (ObjectName (, ObjectName)* ) [";"]
CreateIndexStatement CreateIndexStatement() :{  CreateIndexStatement cis;  String indexName, tableName, columnName;  List < String > columnNames = new ArrayList < String > ();}{  "CREATE" "INDEX" indexName = ObjectName()  {    cis = new CreateIndexStatement(indexName);  }  "ON" tableName = ObjectName()  {    cis.setTableName(tableName);  }  "(" columnName = ObjectName()  {    cis.setColumnNames(columnNames);    columnNames.add(columnName);  }  (    "," columnName = ObjectName()    {      columnNames.add(columnName);    }  )*  ")" [ ";" ]  {    return cis;  }}// CreateTableStatement ::= CREATE TABLE ObjectName 
//                          ( ColumnDefinition (, ColumnDefinition)* [PrimaryKeyDefinition] ) [";"]
CreateTableStatement CreateTableStatement() :{  CreateTableStatement cts;  ColumnDefinition cd;  String s;  String tableName;  List < ColumnDefinition > cds = new ArrayList < ColumnDefinition > ();  List < String > pks = new ArrayList < String > ();}{  "CREATE" "TABLE" tableName = ObjectName()  {    cts = new CreateTableStatement(tableName.toString());  }  "(" cd = ColumnDefinition()  {    cds.add(cd);  }  (    LOOKAHEAD(2)    "," cd = ColumnDefinition()    {      cds.add(cd);    }  )*  [    "," "PRIMARY" "KEY" "(" s = TableColumn()    {      pks.add(s);    }    (      "," s = TableColumn()      {        pks.add(s);      }    )*    ")"  ]  ")" [ ";" ]  {    cts.setColumns(cds);    if (pks.size() > 0)    {      cts.setPrimaryKeyColumns(pks);    }    return cts;  }}// ColumnDefinition ::= TableColumn DataType Modifier*
ColumnDefinition ColumnDefinition() :{  String s;  DataType d;  ColumnDefinition cd = new ColumnDefinition();}{  s = TableColumn()  {    cd.setName(s);  }  d = DataType()  {    cd.setType(d);  }  (    s = Modifier()    {      if (s.equals("NOT NULL"))      {        cd.setNotNull(true);      }      if (s.equals("PRIMARY KEY"))      {        cd.setPrimaryKey(true);        cd.setNotNull(true);      }    }  )*  {    return cd;  }}// TableColumn ::= ObjectName [ "." ObjectName ] [ "." ObjectName ]
String TableColumn() :{  StringBuffer buf = new StringBuffer();  String s;}{  // table.column
  s = ObjectName()  {    buf.append(s);  }  [    LOOKAHEAD(2)    "." s = ObjectName()    {      buf.append("." + s);    }  ]  [    "." s = ObjectName()    {      buf.append("." + s);    }  ]  {    return buf.toString();  }}// ObjectName ::= <S_IDENTIFIER>
String ObjectName() :{  Token t;}{  t = < S_IDENTIFIER >  {    return t.toString();  }}// Relop ::= "=" | "!=" | "#" | "<>" | ">" | ">=" | "<" | "<="
String Relop() :{  Token op;}{  (    op = "="  | op = "!="  | op = "#"  | op = "<>"  | op = ">"  | op = ">="  | op = "<"  | op = "<="  )  {    return op.toString();  }}// ColumnName ::= ObjectName [ "." ObjectName [ "." ObjectName ]]String ColumnName() :{  String name;  StringBuilder sb = new StringBuilder();}{  name = ObjectName()  {    sb.append(name);  }  [    "." name = ObjectName()    {      sb.append("." + name);    }    [      "." name = ObjectName()      {        sb.append("." + name);      }    ]  ]  {    return sb.toString();  }}// TableName ::= ObjectName "." ObjectName
TableName TableName() :{  String vdbName, tableName;}{  vdbName = ObjectName() "." tableName = ObjectName()  {    return new TableName(vdbName, tableName);  }}/* --------------- General Productions ends here --------------- *//* ----------- SQL productions start here ----------------- */// SelectStatement ::= SelectWithoutOrder [OrderByClause]
SelectStatement SelectStatement() :{  SelectStatement q;  List < OrderBy > v;}{  q = SelectWithoutOrder()  [    v = OrderByClause()    {      q.addOrderBy(v);    }  ]  {    return q;  }}// SelectWithoutOrder ::= SELECT [ ALL | DISTINCT ] SelectList FromClause 
//                        [ WhereClause ] [ GroupByClause ] [ HavingClause ]
SelectStatement SelectWithoutOrder() :{  SelectStatement q = new SelectStatement();  List < SelectItem > select;  List < TableReference > from;  ExpressionOrConstant where = null, e;  GroupByHaving groupby = null;}{  "SELECT"  [    "ALL"  | "DISTINCT"    {      q.setDistinct(true);    }  ]  select = SelectList() from = FromClause() [ where = WhereClause() ] [ groupby = GroupByClause() ]  [    "HAVING" e = SQLExpression()    {      if (groupby == null)      {        groupby = new GroupByHaving(new ArrayList < ExpressionOrConstant > ());      }      groupby.setHaving(e);    }  ]  {    q.addSelect(select);    q.addFrom(from);    q.addWhere(where);    q.addGroupBy(groupby);    return q;  }}// SelectList ::= COUNT(*) | SelectItem (, SelectItem)* | 
//                    COUNT "(" [ ALL | DISTINCT ] <ObjectName> ")"
List < SelectItem > SelectList() :{  List < SelectItem > v = new ArrayList < SelectItem > (8);  SelectItem elem;  String s;  StringBuffer b = new StringBuffer();  boolean countDistinct = false;}{  LOOKAHEAD(3)  "COUNT" "(" "*" ")"  {    v.add(new SelectItem("COUNT(*)"));    return v;  }| LOOKAHEAD(SelectItem())  elem = SelectItem()  {    v.add(elem);  }  (    "," elem = SelectItem()    {      v.add(elem);    }  )*  {    return v;  }| LOOKAHEAD(3)  "COUNT" "("  {    b.append("COUNT(");  }  [    "ALL"  | "DISTINCT"    {      b.append("DISTINCT ");      countDistinct = true;    }  ]  s = ObjectName() ")"  {    b.append(s + ")");  }  {    elem = new SelectItem(b.toString());    elem.setCountDistinct(countDistinct);    v.add(elem);    return v;  }}// SelectItem() ::= SQLSimpleExpression [ [AS] Alias ]
SelectItem SelectItem() :{  SelectItem it = new SelectItem();  ExpressionOrConstant e;  Token tk;}{  e = SQLSimpleExpression()  {    it.setExpression(e);  }  [    [ "AS" ] tk = < S_IDENTIFIER >    {      it.setAlias(tk.toString().trim());    }  ]  {    return it;  }}// FromClause ::= TableReference (, TableReference)*
List < TableReference > FromClause() :{  List < TableReference > v = new ArrayList < TableReference > (8);  TableReference f;}{  "FROM" f = TableReference()  {    v.add(f);  }  (    "," f = TableReference()    {      v.add(f);    }  )*  {    return v;  }}// TableNameAndAlias ::= TableName [ [AS] Alias ]TableNameAndAlias TableNameAndAlias() :{  String vdbName, tableName;  TableNameAndAlias tableNameAndAlias;  Token tk;}{  vdbName = ObjectName() "." tableName = ObjectName()  {    tableNameAndAlias = new TableNameAndAlias(vdbName, tableName);  }  [    [ "AS" ] tk = < S_IDENTIFIER >    {      tableNameAndAlias.setAlias(tk.toString());    }  ]  {    return tableNameAndAlias;  }}// TableReference ::= TableNameAndAlias | JoinedTable
// NB: Modified from SQL92 BNF to avoid left recursion
TableReference TableReference() :{  TableReference tableRef;  TableNameAndAlias tableName;  JoinedTable joinedTable;}{  "(" tableRef = TableReference() ")"  {    return tableRef;  }| tableName = TableNameAndAlias()  [    joinedTable = JoinedTable()    {      joinedTable.setTableRef1(new TableReference(tableName));      return new TableReference(joinedTable);    }  ]  {    return new TableReference(tableName);  }}// JoinedTable ::= [NATURAL] ( INNER | OuterJoinType() [OUTER] | UNION )
//                 JOIN TableReference() [ JoinSpecification ]
JoinedTable JoinedTable() :{  boolean natural = false;  JoinType joinType = null;  OuterJoinType outerJoinType = null;  TableReference tableRef2;  JoinSpecification joinSpec = null;}{  [    "NATURAL"    {      natural = true;    }  ]  (    "INNER"    {      joinType = JoinType.INNER;    }  | outerJoinType = OuterJoinType() [ "OUTER" ]    {      joinType = JoinType.OUTER;    }  | "UNION"    {      joinType = JoinType.UNION;    }  )  "JOIN" tableRef2 = TableReference()  [    LOOKAHEAD(2)    joinSpec = JoinSpecification()  ]  {    if (outerJoinType == null)    {      return new JoinedTable(null, tableRef2, natural, joinSpec, joinType);    }    else    {      return new JoinedTable(null, tableRef2, natural, joinSpec, outerJoinType);    }  }}// OuterJoinType ::= "LEFT" | "RIGHT" | "FULL"
OuterJoinType OuterJoinType() :{  OuterJoinType outerJoinType;}{  (    "LEFT"    {      outerJoinType = OuterJoinType.LEFT;    }  | "RIGHT"    {      outerJoinType = OuterJoinType.RIGHT;    }  | "FULL"    {      outerJoinType = OuterJoinType.FULL;    }  )  {    return outerJoinType;  }}// JoinSpecification ::= "ON" SQLExpression() |
//                       "USING" "(" ObjectName() ( "," ObjectName() )* ")"
JoinSpecification JoinSpecification() :{  ExpressionOrConstant exp;  List < String > columnNames;  String columnName;}{  "ON" exp = SQLExpression()  {    return new JoinSpecification(exp);  }| "USING" "(" columnName = ObjectName()  {    columnNames = new ArrayList < String > ();    columnNames.add(columnName);  }  (    "," columnName = ObjectName()    {      columnNames.add(columnName);    }  )*  ")"  {    return new JoinSpecification(columnNames);  }}// WhereClause ::= "WHERE" SQLExpression()
ExpressionOrConstant WhereClause() :{  ExpressionOrConstant e;}{  "WHERE" e = SQLExpression()  {    return e;  }}// ProducerPredicate ::= "WHERE" ObjectName() "=" (<S_CHAR_LITERAL> | <S_NUMBER>)
//                       ( "AND" ObjectName() "=" (<S_CHAR_LITERAL> | <S_NUMBER>) )*
ProducerPredicate ProducerPredicate() :{  List < ColumnValue > columnValues = new ArrayList < ColumnValue > ();  String columnName;  Token columnValueToken;  ColumnValue colVal;}{  "WHERE" columnName = ObjectName() "="  (    columnValueToken = < S_CHAR_LITERAL >    {      String s = columnValueToken.toString();      s = s.replace("''", "'");      s = s.substring(1, s.length() - 1);      colVal = new ColumnValue(columnName, new Constant(s, Type.STRING));      columnValues.add(colVal);    }  | columnValueToken = < S_NUMBER >    {      colVal = new ColumnValue(columnName, new Constant(columnValueToken.toString(), Type.NUMBER));      columnValues.add(colVal);    }  )  (    "AND" columnName = ObjectName() "="    (      columnValueToken = < S_CHAR_LITERAL >      {        String s = columnValueToken.toString();        s = s.replace("''", "'");      	s = s.substring(1, s.length() - 1);        colVal = new ColumnValue(columnName, new Constant(s, Type.STRING));        columnValues.add(colVal);      }    | columnValueToken = < S_NUMBER >      {        colVal = new ColumnValue(columnName, new Constant(columnValueToken.toString(), Type.NUMBER));        columnValues.add(colVal);      }    )  )*  {    return new ProducerPredicate(columnValues);  }}// GroupByClause ::= "GROUP" "BY" SQLExpressionList()
GroupByHaving GroupByClause() :{  GroupByHaving g = null;  List < ExpressionOrConstant > v;}{  "GROUP" "BY" v = SQLExpressionList()  {    g = new GroupByHaving(v);  }  {    return g;  }}// OrderByClause ::= "ORDER" "BY" SQLSimpleExpression() ["ASC" | "DESC"]
//                   ( "," SQLSimpleExpression() ["ASC" | "DESC"] )*
List < OrderBy > OrderByClause() :{  List < OrderBy > v = new ArrayList < OrderBy > ();  ExpressionOrConstant e;  OrderBy ob;}{  "ORDER" "BY" e = SQLSimpleExpression()  {    ob = new OrderBy(e);  }  [    "ASC"  | "DESC"    {      ob.setAscOrder(false);    }  ]  {    v.add(ob);  }  (    "," e = SQLSimpleExpression()    {      ob = new OrderBy(e);    }    [      "ASC"    | "DESC"      {        ob.setAscOrder(false);      }    ]    {      v.add(ob);    }  )*  {    return v;  }}// SQLExpression ::= SQLAndExpression() ( "OR" SQLAndExpression() )*
ExpressionOrConstant SQLExpression() :{  ExpressionOrConstant e1, e2;  Expression e = null;  boolean single = true;}{  e1 = SQLAndExpression()  (    "OR" e2 = SQLAndExpression()    {      if (single)      {        e = new Expression("OR", e1);      }      single = false;      e.addOperand(e2);    }  )*  {    return (single ? e1 : e);  }}// SQLAndExpression ::= SQLUnaryLogicalExpression() ( "AND" SQLUnaryLogicalExpression() )*
ExpressionOrConstant SQLAndExpression() :{  ExpressionOrConstant e1, e2;  Expression e = null;  boolean single = true;}{  e1 = SQLUnaryLogicalExpression()  (    "AND" e2 = SQLUnaryLogicalExpression()    {      if (single)      {        e = new Expression("AND", e1);      }      single = false;      e.addOperand(e2);    }  )*  {    return (single ? e1 : e);  }}// SQLUnaryLogicalExpression ::= ["NOT"] SQLRelationalExpression()
ExpressionOrConstant SQLUnaryLogicalExpression() :{  ExpressionOrConstant e1;  boolean not = false;}{  [    "NOT"    {      not = true;    }  ]  e1 = SQLRelationalExpression()  {    if (not)    {      return new Expression("NOT", e1);    }    else    {      return e1;    }  }}// SQLRelationalExpression ::= ( "(" SQLExpressionList() ")" | SQLSimpleExpression() )
//                             [ SQLRelationalOperatorExpression() | SQLInClause() | SQLBetweenClause() |
//                               SQLLikeClause() | IsNullClause() ]
ExpressionOrConstant SQLRelationalExpression() :{  ExpressionOrConstant eleft;  Expression eright = null;  List < ExpressionOrConstant > v;}{  /* Only after looking past "(", Expression() and "," we will know that
       it is expression list */  (    LOOKAHEAD("(" SQLSimpleExpression() ",")    "(" v = SQLExpressionList() ")"    {      eleft = new Expression(",");      ((Expression) eleft).setOperands(v);    }  | eleft = SQLSimpleExpression()  )  /* Lookahead(2) is required because of NOT IN, NOT BETWEEN and NOT LIKE */  [    eright = SQLRelationalOperatorExpression()  | LOOKAHEAD(2)    (      eright = SQLInClause()    )  | LOOKAHEAD(2)    (      eright = SQLBetweenClause()    )  | LOOKAHEAD(2)    (      eright = SQLLikeClause()    )  | eright = IsNullClause()  ]  {    if (eright == null)    {      return eleft;    }    List < ExpressionOrConstant > v2 = eright.getOperands();    if (v2 == null)    {      v2 = new ArrayList < ExpressionOrConstant > (); // For IS NULL, which is unary!
    }    v2.add(0, eleft);    eright.setOperands(v2);    return eright;  }}// SQLExpressionList ::= SQLSimpleExpression() ( "," SQLSimpleExpression() )*
List < ExpressionOrConstant > SQLExpressionList() :{  List < ExpressionOrConstant > v = new ArrayList < ExpressionOrConstant > (8);  ExpressionOrConstant e;}{  e = SQLSimpleExpression()  {    v.add(e);  }  (    "," e = SQLSimpleExpression()    {      v.add(e);    }  )*  {    return v;  }}// SQLRelationalOperatorExpression ::= Relop() ( SQLSimpleExpression() )
Expression SQLRelationalOperatorExpression() :{  Expression e;  ExpressionOrConstant eright;  String op;}{  op = Relop()  {    e = new Expression(op);  }  eright = SQLSimpleExpression()  {    e.addOperand(eright);    return e;  }}// SQLInClause ::= ["NOT"] "IN" "(" ( SQLExpressionList() ) ")"
Expression SQLInClause() :{  Expression e;  boolean not = false;  List < ExpressionOrConstant > v;}{  [    "NOT"    {      not = true;    }  ]  "IN"  {    e = new Expression(not ? "NOT IN" : "IN");  }  "("  (    v = SQLExpressionList()    {      e.setOperands(v);    }  )  ")"  {    return e;  }}// SQLBetweenClause ::= ["NOT"] "BETWEEN" SQLSimpleExpression() "AND" SQLSimpleExpression()
Expression SQLBetweenClause() :{  Expression e;  ExpressionOrConstant e1, e2;  boolean not = false;}{  [    "NOT"    {      not = true;    }  ]  "BETWEEN" e1 = SQLSimpleExpression() "AND" e2 = SQLSimpleExpression()  {    if (not)    {      e = new Expression("NOT BETWEEN", e1, e2);    }    else    {      e = new Expression("BETWEEN", e1, e2);    }    return e;  }}// SQLLikeClause ::= ["NOT"] "LIKE" SQLSimpleExpression()
Expression SQLLikeClause() :{  ExpressionOrConstant eright;  Expression e;  boolean not = false;}{  [    "NOT"    {      not = true;    }  ]  "LIKE" eright = SQLSimpleExpression()  {    if (not)    {      e = new Expression("NOT LIKE", eright);    }    else    {      e = new Expression("LIKE", eright);    }    return e;  }}// IsNullClause ::= "IS" ["NOT"] "NULL"
Expression IsNullClause() :{  boolean not = false;}{  "IS"  [    "NOT"    {      not = true;    }  ]  "NULL"  {    return (not ? new Expression("IS NOT NULL") : new Expression("IS NULL"));  }}// SQLSimpleExpression ::= SQLMultiplicativeExpression() 
//                         ( ( "+" | "-" | "||" ) SQLMultiplicativeExpression() )*
ExpressionOrConstant SQLSimpleExpression() :{  Token op;  ExpressionOrConstant e1, e2;  Expression e = null;}{  e1 = SQLMultiplicativeExpression()  (    (      op = "+"    | op = "-"    | op = "||"    )    e2 = SQLMultiplicativeExpression()    {      e = new Expression(op.toString(), e1);      e.addOperand(e2);      e1 = e;    }  )*  {    return e1;  }}// SQLMultiplicativeExpression ::= SQLExponentExpression()
//                                 ( ( "*" | "/" ) SQLExponentExpression() )*
ExpressionOrConstant SQLMultiplicativeExpression() :{  Token op;  ExpressionOrConstant e1, e2;  Expression e = null;}{  e1 = SQLExponentExpression()  (    (      op = "*"    | op = "/"    )    e2 = SQLExponentExpression()    {      e = new Expression(op.toString(), e1);      e.addOperand(e2);      e1 = e;    }  )*  {    return e1;  }}// SQLExponentExpression ::= SQLUnaryExpression() ("**" SQLUnaryExpression())*
ExpressionOrConstant SQLExponentExpression() :{  Token op;  ExpressionOrConstant e1, e2;  Expression e = null;  boolean single = true;}{  e1 = SQLUnaryExpression()  (    op = "**" e2 = SQLUnaryExpression()    {      if (single)      {        e = new Expression(op.toString(), e1);      }      single = false;      e.addOperand(e2);    }  )*  {    return (single ? e1 : e);  }}// SQLUnaryExpression ::= [ "+" | "-" ] SQLPrimaryExpression()
ExpressionOrConstant SQLUnaryExpression() :{  Token op = null;  ExpressionOrConstant e1, e;}{  [    op = "+"  | op = "-"  ]  e1 = SQLPrimaryExpression()  {    if (op == null)    {      e = e1;    }    else    {      e = new Expression(op.toString(), e1);    }    return e;  }}// SQLPrimaryExpression ::= "NULL" | OuterJoineExpression() | "COUNT" "(" "*" ")" |
//                          AggregateFunc() | TableColumn() | <S_NUMBER> | <S_CHAR_LITERAL> |
//                          <S_BIND> | "(" SQLExpression() ")"
ExpressionOrConstant SQLPrimaryExpression() :{  Token t;  String s, s2;  ExpressionOrConstant e;}{  "NULL"  {    return new Constant("NULL", Type.NULL);  }| LOOKAHEAD(OuterJoinExpression())  OuterJoinExpression()  {    return new Expression("_NOT_SUPPORTED"); //TBD
  }| LOOKAHEAD(3)  "COUNT" "(" "*" ")"  {    return new Expression("COUNT", new Constant("*", Type.COLUMN_NAME));  }| s = AggregateFunc() "(" s2 = TableColumn() ")"  {    return new Expression(s, new Constant(s2, Type.COLUMN_NAME));  }| s = TableColumn()  {    return new Constant(s, Type.COLUMN_NAME);  }| t = < S_NUMBER >  {    return new Constant(t.toString(), Type.NUMBER);  }| t = < S_CHAR_LITERAL >  {    s = t.toString();    s = s.replace("''", "'");    s = s.substring(1, s.length() - 1);    return new Constant(s, Type.STRING);  }| t = < S_BIND >  {    return new Constant(t.toString(), Type.STRING);  }| "(" e = SQLExpression() ")"  {    return e;  }}// ColumnValue ::= "NULL" | <S_NUMBER> | <S_CHAR_LITERAL>Constant ColumnValue() :{  Token t;  String s;}{  "NULL"  {    return new Constant("NULL", Type.NULL);  }| [ "+" ] t = < S_NUMBER >  {    return new Constant(t.toString(), Type.NUMBER);  }| "-" t = < S_NUMBER >  {    return new Constant("-" + t.toString(), Type.NUMBER);  }| t = < S_CHAR_LITERAL >  {    s = t.toString();    s = s.replace("''", "'");    s = s.substring(1, s.length() - 1);    return new Constant(s, Type.STRING);  }}// AggregateFunc ::= "SUM" | "AVG" | "MAX" | "MIN" | "COUNT"
String AggregateFunc() :{  Token t;}{  (    t = "SUM"  | t = "AVG"  | t = "MAX"  | t = "MIN"  | t = "COUNT"  )  {    return t.toString();  }}// OuterJoinExpression ::= ObjectName() [ "." ObjectName() [ "." ObjectName() ] ] "(" "+" ")"
void OuterJoinExpression() :{}{  // user.table.col
  ObjectName()  [    "." ObjectName() [ "." ObjectName() ]  ]  "(" "+" ")"}